<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Read, Inspired and Write.]]></title><description><![CDATA[As long as we dare to dream and do not get in the way of ourseleves, anything is possible]]></description><link>https://techoi.github.io</link><generator>RSS for Node</generator><lastBuildDate>Wed, 26 Jun 2019 08:36:53 GMT</lastBuildDate><item><title><![CDATA[Next.js 서버사이드 랜더링 배포 환경 이중화 고려사항]]></title><description><![CDATA[AWS ec2 인스턴스에 node server를 여러개 두고 이를 ELB로 연결할 경우 고려해야할 사항]]></description><link>https://techoi.github.io/posts/frontend-server-deploy-setup</link><guid isPermaLink="false">https://techoi.github.io/posts/frontend-server-deploy-setup</guid><pubDate>Wed, 26 Jun 2019 09:32:05 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;h5&gt;AWS ec2 인스턴스에 node server를 여러개 두고 이를 ELB로 연결할 경우 고려해야할 사항&lt;/h5&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;결론만 말하면 SSR application을 build할때 build-id를 동일하게 해줘야 ELB를 통해 요청이 인스턴스를 오갈때 문제가 발생하지 않는다.
마찬가지로 무중단 배포를 고려하고 있다면, ELB의 타겟그룹을 바꿔치기하는 식으로 접근해야 할 것이다.
또한, build-id로 인한 404 에러가 날 경우는 url를 다시 한번 호출하는 식의 redirect 코드를 넣어 서비스의 연속성을 유지해야할 것이다.&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;h3&gt;SPA와 SEO와 SSR&lt;/h3&gt;
&lt;p&gt;일반적인 SPA(Single Page Application)의 경우, 프론트엔드 빌드 파일을 사용자에게 서빙하는데
굳이 노드 서버를 두지 않아도된다.(S3와 cloudfront를 사용해서 서빙하는 경우도 있음)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;일반적인 SPA(React, Vue…) 프레임워크를 통해 어플리케이션을 만들 경우, 결과물을 js파일로 번들링해두고, 이를 사용자(client side)의 브라우저가 해석해서 사용자가 볼 수 있도록 한다.&lt;/p&gt;
&lt;p&gt;즉, js 파일을 해석할 수 있는 브라우저를 통해야 사용자가 이를 볼 수 있게 된다.&lt;/p&gt;
&lt;p&gt;웹 어플리케이션을 만들었다면, 이를 더 많은 사용자들이 사용할 수 있도록 서비스를 퍼트리는 작업이 필요하다.
이를 위해 고려하게 되는 것이 SEO(Search Engine Optimization, 검색 최적화)다.&lt;/p&gt;
&lt;p&gt;구글느님같은 경우 search engine 봇(bot)이 알아서 node 파일을 실행해서 페이지를 수집해가 주신다지만
그렇지 않은 몇몇 search engine 봇들은 그렇게 똑똑하지 않다. &lt;del&gt;하려면 할 수 있겠지만 왜 안하는지는 나도 모르겠… 이미 브라우저에서 긁어가는 걸로 충분하단건가..&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;html 와 같은 정적 파일만 읽을줄 아는 봇들이 SPA 어플리케이션의 내용을 읽어가 검색엔진에서 검색되도록 하기 위해서는
우리가 친히 js 파일을 해석해서 정적 파일로 전해드려야 한다.&lt;/p&gt;
&lt;p&gt;이를 위해서 우리는 node 서버를 두고, js 파일을 해석해서 정적 파일 형태로 제공하는 기술 SSR(Server Side Render)를 고려하게 된다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3&gt;SSR의 배포 환경과 무중단 배포&lt;/h3&gt;
&lt;/blockquote&gt;
&lt;h5&gt;백엔드의 배포 환경은 구성하기 나름이겠지만 도커를 사용하는 경우와 AWS에서 제공하는 Code Deploy를 사용하는 경우가 거의 대부분을 인 것같다. ~~ 이 두가지만 경험이 있..~~ 프론트엔드의 경우는 pm2를 통해서 인스턴스를 관리하는 것만으로도 충분한 경우가 많겠지만…&lt;/h5&gt;
&lt;p&gt;일반적인 배포환경&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Docker를 사용하는 경우, Rancher나 Docker-Swarm, Kubernetes를 통해 인스턴스들을 관리&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AWS 인스턴스를 Code Deploy로 관리&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pm2를 사용하여 다중 인스턴스를 관리&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;서비스를 업데이트하는 과정에서 사용자의 사용성을 최대한 해치지 않기 위해서는 무중단 배포(Continuous Delivery)를 고려해야 한다.
(Blue-Green 배포, Canary 배포… 등의 방법론이 있음)&lt;/p&gt;
&lt;p&gt;당연한 이야기이겠지만, 어떤 방식으로 배포를 하더라도 완전한 무중단 배포는 불가능하지 않을까 싶다. 그럼에도 최대한 안정적으로 서비스를 제공할 수 있는 방식을 추구해야…&lt;/p&gt;
&lt;p&gt;본론으로 돌아가서&lt;/p&gt;
&lt;p&gt;SPA는 js 파일로 어플리케이션을 build하는데 이때, webpack과 같은 번들링 툴들이 알아서 hash 값 등으로 static 파일들의 이름을 정해버린다.(옵션을 통해서 파일이름을 특정 규칙으로 만들어줄 수도 있음)&lt;/p&gt;
&lt;p&gt;만약, ELB로 여러 인스턴스를 묶어놨는데, 각 인스턴스마다 다른 파일 이름을 바라보고 있다면 서버에서 파일을 찾을 수 없다는 404 에러코드를 영접하게 된다.&lt;/p&gt;
&lt;p&gt;이를 해소하는 방법은 간단하다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;모든 인스턴스가 같은 build를 바라보면 됨&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker를 사용하는 경우, build 파일을 담고 있는 Volume을 share하면 됨&lt;/li&gt;
&lt;li&gt;Code Deploy로 관리하는 경우, build 파일을 만드는 전용 인스턴스를 하나두고, 이 파일을 s3에 올려서 code deploy가 인스턴스를 생성할때 이 파일을 다운받도록 하면 됨&lt;/li&gt;
&lt;li&gt;pm2의 경우, 어차피 -i 옵션으로 instance들을 여러개 켰다면 하나의 빌드파일을 보고 있을 것이라 고려 불필요일듯(?)&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Techoi(테크초이) 메멘토 노트]]></title><description><![CDATA[필요할때마다 구글링하는 것들]]></description><link>https://techoi.github.io/posts/memento</link><guid isPermaLink="false">https://techoi.github.io/posts/memento</guid><pubDate>Tue, 25 Jun 2019 09:32:05 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;h5&gt;기억하긴 비효율적이고 때마다 찾기도 좀 그런…&lt;/h5&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;h3&gt;server&lt;/h3&gt;
&lt;/blockquote&gt;
&lt;h4&gt;Mac host file path&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;/private/etc/hosts&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;h3&gt;css&lt;/h3&gt;
&lt;/blockquote&gt;
&lt;h4&gt;css 인접, 형제, 자손, 자식 선택자&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;X Y : 자손(X가 부모든 부모의 부모든 Y 선택)&lt;/li&gt;
&lt;li&gt;X &gt; Y : 자식(X가 부모일경우에만 Y 선택)&lt;/li&gt;
&lt;li&gt;X + Y : 인접형제(Y의 형제로 앞에 어딘가 X가 있으면 X 선택)&lt;/li&gt;
&lt;li&gt;X ~ Y : 일반형제(Y앞에 X가 있는 경우 Y 선택)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;css padding, margin 순서&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;상우하좌&lt;/li&gt;
&lt;li&gt;상하 좌우&lt;/li&gt;
&lt;li&gt;상 좌우 하&lt;/li&gt;
&lt;li&gt;상하는 같고 좌우는 다를때는 각각 써줘야함…&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;h3&gt;node&lt;/h3&gt;
&lt;/blockquote&gt;
&lt;h4&gt;pm2 .json에 npm script args 실행&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;json&quot;&gt;&lt;pre class=&quot;language-json&quot;&gt;&lt;code class=&quot;language-json&quot;&gt;  &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;apps&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token property&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;waug_react_beta&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;token property&quot;&gt;&quot;script&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;npm&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;token property&quot;&gt;&quot;args&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;run -- dev&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;token property&quot;&gt;&quot;watch&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;start, test 등 npm run 없이 실행가능한 예약어들은 “args”: “start” 만 해도되지만, 예약안된 custom scripts는 &lt;code class=&quot;language-text&quot;&gt;--&lt;/code&gt; 로 args 연결 필요&lt;/p&gt;
&lt;p&gt;To bo continue…&lt;/p&gt;</content:encoded></item><item><title><![CDATA[프론트엔드 기술 스택 - 관심분야]]></title><description><![CDATA[서버사이드 리액트 글로벌 웹서비스 리뉴얼]]></description><link>https://techoi.github.io/posts/what-i-am-interested-in</link><guid isPermaLink="false">https://techoi.github.io/posts/what-i-am-interested-in</guid><pubDate>Fri, 21 Jun 2019 11:01:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;h3&gt;서버사이드 리액트 글로벌 웹서비스 리뉴얼&lt;/h3&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;최근 진행한 회사의 신규 프론트엔드 서비스 기술 스택&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/images/2019-06-21/react-logo.png&quot;&gt;
&lt;img src=&quot;/images/2019-06-21/next-js-logo.png&quot;&gt;
&lt;img src=&quot;/images/2019-06-21/typescript-logo.png&quot;&gt;
&lt;img src=&quot;/images/2019-06-21/sass-logo.png&quot;&gt;
&lt;img src=&quot;/images/2019-06-21/webpack-logo.jpeg&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;테스트 툴로 선정했지만, 계속 쓰게 될지는 모를 Jest…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/images/2019-06-21/jest-logo.png&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;서비스 전반적으로 적용은 힘들겠지만, 그래도 어느정도 조금씩 녹여보고 싶은 기술&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/images/2019-06-21/serverless-logo.png&quot;&gt;
&lt;img src=&quot;/images/2019-06-21/graphql-logo.png&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;관심있던 기술을 둘러보고 이것저것 접하기 위해서는 역시 일에다가 적용하는 거지~&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;완전 새로운 기술은 아니지만, 어느정도 안정성을 인정받은 ** Trady ** 한 기술들이기에..&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;프론트엔드 개발자가 혼자라서…&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;조금 외롭기하나,&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;정식 문서와 친구먹고, 프론트엔드 커뮤니티에 속할 이유가 되고,
새로운 프로젝트의 기술 스택 선택에 자유도가 있어서 좋다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;다른 프론트엔드 개발자와의 소통은 &lt;strong&gt;오픈소스&lt;/strong&gt; 활동을 통해서 커버업할 수 있길…&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[Git key 생성 및 계정 설정 분리하기]]></title><description><![CDATA[나만의 깃 세팅 구성하기]]></description><link>https://techoi.github.io/posts/seperate-git-user-with-key</link><guid isPermaLink="false">https://techoi.github.io/posts/seperate-git-user-with-key</guid><pubDate>Wed, 19 Jun 2019 20:53:56 GMT</pubDate><content:encoded>&lt;h3&gt;나만의 깃 세팅 구성하기&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;블로그를 작성할 시간을 내는게 정말 쉽지 않다. 그래도 자주 써보자는 생각이 다시 들게 해준 상황 덕분에 정리한다&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;본론으로 바로 들어간다.&lt;/p&gt;
&lt;p&gt;이슈는 다음과 같다.&lt;/p&gt;
&lt;h3&gt;특정 폴더에서만 특정한 git user와 ssh키를 사용하고 싶다.&lt;/h3&gt;
&lt;p&gt;회사 업무와 개인 프로젝트를 하나의 맥북으로 하고 있기 때문에 필요하다…
&lt;del&gt;회사에서 맥북을 안사줘서 개인 맥북을 사용해야하는ㅠㅠ 눙물이 난다.&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;TODO LIST&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;계정별 ssh 키 생성&lt;/li&gt;
&lt;li&gt;특정 폴더를 위한 &lt;code class=&quot;language-text&quot;&gt;.gitconfig&lt;/code&gt; 파일 생성&lt;/li&gt;
&lt;li&gt;특정 폴더에서만 &lt;code class=&quot;language-text&quot;&gt;2&lt;/code&gt;에서 설정한 config 파일을 사용하도록 설정&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;1. 계정별 ssh 키 생성&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;아무 설정도 애초에 없었다고 가정하고 간다. 만약 특정 설정이 있었다면 지우고 하면 됨&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;shell&quot;&gt;&lt;pre class=&quot;language-shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;  $ cd ~/.ssh
  $ ssh-keygen -t rsa -C &amp;quot;username@github.com&amp;quot; // 계정 이름
  $ Enter file in ....
  /* SSH 키 이름 설정 편의상 username@github.com으로 생성 추천*/

  $ ls // 파일 생성 여부 확인&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 방식을 반복해서 계정마다 키를 생성한다.&lt;/p&gt;
&lt;p&gt;생성한 키는 에이젠트에 추가&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;shell&quot;&gt;&lt;pre class=&quot;language-shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;  $ ssh-add ~/.ssh/username@github.com&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SSH 키 관리는 &lt;code class=&quot;language-text&quot;&gt;~/.ssh/config&lt;/code&gt; 파일에서&lt;/p&gt;
&lt;p&gt;자세한 내용은 &lt;a href=&quot;%22https://blog.outsider.ne.kr/1448%22&quot;&gt;Outsider님의 블로그&lt;/a&gt; 에 잘 정리되어 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ssh를 새로 만들었으니깐, 전역으로 사용할 user 정보를 가질 계정 설정도 추가로  해주면 됨&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;2. 특정 폴더를 위한 &lt;code class=&quot;language-text&quot;&gt;.gitconfig&lt;/code&gt; 파일 생성&lt;/h2&gt;
&lt;p&gt;이것도 Outsider님의 블로그에 잘 정리되어 있지만…&lt;/p&gt;
&lt;p&gt;개념만 말하면, 특정 폴더(아마도 회사의 workplace)에서만 사용될 &lt;code class=&quot;language-text&quot;&gt;.gitconfig&lt;/code&gt;파일을 만드는 것이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;.gitconfig-work&quot;&gt;&lt;pre class=&quot;language-.gitconfig-work&quot;&gt;&lt;code class=&quot;language-.gitconfig-work&quot;&gt;[user]
  email = username@company.com
  name = techoi&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3. 특정 폴더에서만 특정한 &lt;code class=&quot;language-text&quot;&gt;.gitconfig&lt;/code&gt; 파일 사용하도록 설정&lt;/h2&gt;
&lt;p&gt;위에서 만든 &lt;code class=&quot;language-text&quot;&gt;.gitconfig-work&lt;/code&gt; 파일도 ~/위치에 있고 여기에는 .gitconfig 파일도 있다.&lt;/p&gt;
&lt;p&gt;.gitconfig 파일에 다&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;.gitconfig&quot;&gt;&lt;pre class=&quot;language-.gitconfig&quot;&gt;&lt;code class=&quot;language-.gitconfig&quot;&gt;[includeIf &amp;quot;gitdir:~/company-workspace]
  path = .gitconfig-work&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;만 넣어주면 된다.&lt;/p&gt;
&lt;p&gt;이제 잘됬는지 확인해보자!&lt;/p&gt;
&lt;p&gt;company-workspace 외 폴더에 있는 프로젝트에 가서
&lt;code class=&quot;language-text&quot;&gt;git config --list&lt;/code&gt;를 쳐보면 내 계정의 정보면 보인다.&lt;/p&gt;
&lt;p&gt;company-workspace에 있는 특정 프로젝트에 가서
&lt;code class=&quot;language-text&quot;&gt;git config --list&lt;/code&gt;를 쳐보면 회사에서 쓸 계정이 보인다.&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;h3&gt;추가사항&lt;/h3&gt;
&lt;/blockquote&gt;
&lt;p&gt;ssh를 만들었다고해서 다 끝나는건 아니다.
ssh 생성했으면 ~/.ssh 폴더 안에 &lt;code class=&quot;language-text&quot;&gt;private key&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;public key&lt;/code&gt;가 생성된다.&lt;/p&gt;
&lt;p&gt;이를 github의 경우, [Setting] &gt; [SSH and GPG keys] &gt; [New SSH key]
에서 생성한 public key를 복사해서 넣어주면 된다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4&gt;이것도 귀찮으면&lt;/h4&gt;
&lt;p&gt;애초에 ssh를 따로 만들지도 말고, 그냥 git 로컬 repo에 입력한 &lt;code class=&quot;language-text&quot;&gt;username&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;password&lt;/code&gt;를 저장할 수도 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;  $ &lt;span class=&quot;token function&quot;&gt;git&lt;/span&gt; config credential.helper store&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;
&lt;p&gt;끗&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3&gt;에필로그&lt;/h3&gt;
&lt;p&gt;예전부터 Vim을 잘 쓰고 싶다는 생각만 하다가 일단 시작해보자하는 마음에 기존에 사용하고 있던 IDE에 Vim extension을 추가해버렸다. 그리고 한 2주 버벅이면서 되돌리고 싶다 계속 생각했지만, 오기로 버티다 보니깐 꽤나 손에 익게 되었다. 그후로는 server 작업이든, 기타 mac 설정 작업을 할때 vi을 쓸때 속이 시원해지는 마법이 내게도 생겼다. 아쉬운점은 IDE마다 Vim extension의 기능 차이가 있다는… 혹시나 Vim에 익숙해지고 싶다면 extension 설치를 적극 추천한다. 물론 한동안 manual을 계속 보게 되겠지만…&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[기분 좋게 IE 이슈를 해소하는 방법]]></title><description><![CDATA[리액트 훅스로 IE에서 발생하는 overflow scroll 이슈 해소]]></description><link>https://techoi.github.io/posts/ie-style-issue-solve-with-react-hooks</link><guid isPermaLink="false">https://techoi.github.io/posts/ie-style-issue-solve-with-react-hooks</guid><pubDate>Tue, 18 Jun 2019 20:53:56 GMT</pubDate><content:encoded>&lt;h3&gt;리액트 훅스로 IE에서 발생하는 overflow scroll 이슈 해소&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;블로그를 작성할 시간을 내는게 정말 쉽지 않다. 그래도 자주 써보자는 생각이 다시 들게 해준 상황 덕분에 정리한다&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;본론으로 바로 들어간다.&lt;/p&gt;
&lt;p&gt;이슈는 다음과 같다.
Chrome 류에서는 max-height만 가지고 overflow를 쉽게 관리할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2019-06-18/popup-layout.png&quot; alt=&quot;모달 레이아웃&quot;&gt;&lt;/p&gt;
&lt;p&gt;위의 형태의 레이아웃을 만들기 위해서 Chrome류에서는
부모 component에  max-height를 주고,
스크롤을 붙이고 싶은 component에 height와 overflow: auto;를 주면 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;css&quot;&gt;&lt;pre class=&quot;language-css&quot;&gt;&lt;code class=&quot;language-css&quot;&gt;&lt;span class=&quot;token selector&quot;&gt;.parent&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;max-height&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; 70%&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token selector&quot;&gt;.content&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; 85%&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;overflow&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; auto&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;하지만 한국에서 웹서비스를 운영하고 있다면 어김없기 고려해야하는 IE라는 큰 산이 있다.&lt;/p&gt;
&lt;p&gt;각종 polyfill로 해소할 수 있는 부분은 해소했다 손 치더라도..
스타일링을 돕는 다양한 속성들이 IE에서는 예상과 다르게 보여질때가 있기에…
&lt;del&gt;IE 지원안하고싶…&lt;/del&gt; 이를 대응해줄 필요가 있다!&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;위 스타일을 적용하면 IE에서는 부모 component에 스크롤이 붙어버린다.
그럼 고정하고 싶은 header와 footer가 고정되지 못한다.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이를 해결하는 다양한 방식이 있다.&lt;/p&gt;
&lt;p&gt;가장 간단한 방식은 아마도&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;부모의 사이즈를 고정해버리는 것!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;css&quot;&gt;&lt;pre class=&quot;language-css&quot;&gt;&lt;code class=&quot;language-css&quot;&gt;&lt;span class=&quot;token selector&quot;&gt;.parent&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; 700px&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;딱 봐도 알겠지만, 명료하지만 다양한 경우를 다 담을 수 없다.&lt;/p&gt;
&lt;p&gt;리액트 컴포넌트의 재사용성을 고려하기 위해 다른 방법을 생각해보다가&lt;/p&gt;
&lt;h2&gt;React Hooks 를 활용해보기로 했다.&lt;/h2&gt;
&lt;p&gt;모달 컴포넌트 자체가 애초에 function component였기에  &lt;del&gt;최근 리액트 공식 문서를 다시 읽었기에…&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;요즘은 핫하기도 하지만 어느정도 안정적으로 판단되는 기술들을 새로운 프로젝트에 녹여내는걸로 바쁜 일정에 대한 자기 위안을 삼고 있다(지금 진행하고 있는 신규 프로젝트에는 React, Next.js(SSR), React Hooks, Sass, Type Script, Jest가 기본 골조)&lt;/p&gt;
&lt;p&gt;모달 컴포넌트는 담기는 내용이 통신 결과에 따라 변경되는 구조이기에 빅 사이즈 경우와 작은 사이즈 경우가 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2019-06-18/big-size-popup.png&quot; alt=&quot;빅 사이즈 모달&quot;&gt;
&lt;img src=&quot;/images/2019-06-18/small-size-popup.png&quot; alt=&quot;스몰 사이즈 모달&quot;&gt;&lt;/p&gt;
&lt;p&gt;목표는 부모 component의 height를 자식(스크롤을 달고 싶은) component의 height에 따라 동적으로 설정하는 것!&lt;/p&gt;
&lt;p&gt;자식의 사이즈는 동적으로 결정되므로, 컴포넌트가 그려진 다음에 사이즈를 확인해서 부모의 스타일을 바꿔줘야한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;자식까지 일단 다 그려진다.&lt;/li&gt;
&lt;li&gt;자식의 사이즈를 확인한다.&lt;/li&gt;
&lt;li&gt;자식의 사이즈에 따라 부모의 사이즈를 수정한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;리액트 클래스 컴포넌트를 사용하고 있다면 componentDidMount() life cycle에서 자식의 사이즈를 통해 부모의 사이즈를 바꿔주면 될테고,
바닐라 JS를 사용하고 있다면, JQuery로 load된 후 해당 작업을 하면 될테다.&lt;/p&gt;
&lt;p&gt;리액트 펑션 컴포넌트를 사용하고 있었다면, 라이프 사이클을 사용하기 위해서 클래스 컴포넌트로 바꾸지말고,
리액트 훅스를 사용해주자!&lt;/p&gt;
&lt;h2&gt;React Hooks로 작업한 코드는 다음과 같다.&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;tsx&quot;&gt;&lt;pre class=&quot;language-tsx&quot;&gt;&lt;code class=&quot;language-tsx&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/* tsx 파일 */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; React&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; useState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; useEffect &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;react&apos;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; CheckCategory&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; React&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;SFC&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;Props&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token plain-text&quot;&gt; = () =&gt; &lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; popupBox &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; React&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;createRef&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;HTMLDivElement&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token plain-text&quot;&gt;();
    let popupWrapper = React.createRef&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;HTMLDivElement&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token plain-text&quot;&gt;();

    useEffect(() =&gt; &lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;popupWrapper&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;token comment&quot;&gt;// popupWrapper.current.style.height = popupBox.current &amp;amp;&amp;amp; popupBox.current.clientHeight + 120 + &apos;px&apos;; // 코드 수정&lt;/span&gt;
          popupWrapper&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;style&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;height &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; popupBox&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; popupBox&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;style&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;height &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; popupBox&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;style&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;height &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;120&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;px&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token plain-text&quot;&gt;);

    return (
      &lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token plain-text&quot;&gt;
          ...
            &lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;className&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&apos;&lt;/span&gt;parent&lt;span class=&quot;token punctuation&quot;&gt;&apos;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;token script language-javascript&quot;&gt;&lt;span class=&quot;token script-punctuation punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;popupWrapper&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token plain-text&quot;&gt;
                ...
                &lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;className&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&apos;&lt;/span&gt;content&lt;span class=&quot;token punctuation&quot;&gt;&apos;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;token script language-javascript&quot;&gt;&lt;span class=&quot;token script-punctuation punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; popupBox &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token plain-text&quot;&gt;
                    ...
                &lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token plain-text&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token plain-text&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token plain-text&quot;&gt;
    )&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span style=&quot;color:#ffa8df&quot; &gt; &lt;strong&gt;코드 수정&lt;/strong&gt;&lt;/span&gt; : clientHeight의 경우 checkbox 요소의 checked 여부에 따라 들쑥날쑥한 현상이 발생
&lt;code class=&quot;language-text&quot;&gt;clientHeight&lt;/code&gt;를 &lt;code class=&quot;language-text&quot;&gt;style.height&lt;/code&gt;로 변경&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;scss&quot;&gt;&lt;pre class=&quot;language-scss&quot;&gt;&lt;code class=&quot;language-scss&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/* scss 파일 */&lt;/span&gt;
&lt;span class=&quot;token selector&quot;&gt;.parent &lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;max-height&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; 70%&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token selector&quot;&gt;.content &lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;overflow&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; auto&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;@include&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;respond-to&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;pc&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* 요건 반응형 대응 코드(sass를 사용하고 있다는?)*/&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; 1150px&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; 85%&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;useEffect를 사용해서 render하는 타이밍마다
자식의 사이즈를 통해 부모의 height를 동적으로 줄 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;사실 이 코드도 보면 고정값으로 120 을 더하고 있는 부분이 있는데, 이는 모달 컴포넌트의 header와 footer의 고정적인 높이의 합이므로 예외로 하자&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;최적의 코드라는 생각은 아니지만, IE를 대응해야하는 &lt;del&gt;조금은 귀찮은&lt;/del&gt; 상황에서 스스로를 위안할 수 있는 접근을 찾다보니…&lt;/p&gt;</content:encoded></item><item><title><![CDATA[첫 시작치고 괜찮다!]]></title><description><![CDATA[Gatsby로 새로운 블로그를 시작했다. github.io]]></description><link>https://techoi.github.io/posts/the-beginning</link><guid isPermaLink="false">https://techoi.github.io/posts/the-beginning</guid><pubDate>Fri, 15 Feb 2019 09:53:56 GMT</pubDate><content:encoded>&lt;h3&gt;굳이 블로그를 만들기까지 해야할까 싶었지만…&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;크게 3가지 이유로 인해 작업을 시작했다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;markdown에 익숙해지고 싶다.&lt;/li&gt;
&lt;li&gt;자유도가 높은 환경에서 해보고 싶다.&lt;/li&gt;
&lt;li&gt;github.io를 써보고 싶다.&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;여러가지 선택지들이 있었지만, &lt;code class=&quot;language-text&quot;&gt;jekyll&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;hexo&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;gatsby&lt;/code&gt; 정도를 후보군에 두고 고민하다가… &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(결국에는 gatsby로 선택 뭔가 헤어 왁스 느낌이 나는 이름이지만)&lt;/p&gt;
&lt;p&gt;기존에 개인용 저장소처럼 사용하던 Evernote와 tistory와는 어떤 차별성을 줘야 할 지 고민되지만 일단 나눠서 가는 쪽으로 생각하고 있다.&lt;/p&gt;
&lt;p&gt;아마도 github.io는 public한 내용이 올라가게 될 것같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Gatsby&lt;/strong&gt;는 &lt;em&gt;React&lt;/em&gt;와 &lt;em&gt;graphQL&lt;/em&gt;을 사용하고 있기에 커스텀하면서 자연스레 공부하는 꼴이 될 듯?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;얼마전에 본 &lt;a href=&quot;%22https://www.youtube.com/watch?v=QyxES-SUq_E%22&quot;&gt;2019년 반드시 알아야하는 웹 개발 트렌드 5가지&lt;/a&gt;에서도 언급된 기술 중 2개나 가져가는 트렌디함 이란(사실 serverless 말고는 2018년에도 반드시 알아야할 웹개발 트렌드였을듯…?)&lt;/p&gt;</content:encoded></item></channel></rss>